import { ObjectId } from 'mongodb';

/**
 * Utility functions ƒë·ªÉ x·ª≠ l√Ω balance m·ªôt c√°ch an to√†n v√† ch√≠nh x√°c
 * S·ª≠ d·ª•ng MongoDB aggregation pipeline ƒë·ªÉ tr√°nh race condition
 */

export interface BalanceUpdate {
  available: number;
  frozen: number;
}

/**
 * ƒê·∫∑t l·ªánh giao d·ªãch - Tr·ª´ ti·ªÅn kh·∫£ d·ª•ng v√† c·ªông ti·ªÅn ƒë√≥ng bƒÉng
 */
export async function placeTrade(db: any, userId: string, amount: number): Promise<boolean> {
  try {
    const updateResult = await db.collection('users').updateOne(
      { 
        _id: new ObjectId(userId),
        'balance.available': { $gte: amount }
      },
      {
        $inc: {
          'balance.available': -amount,
          'balance.frozen': amount
        },
        $set: { updatedAt: new Date() }
      }
    );

    if (updateResult.modifiedCount === 0) {
      throw new Error('Balance kh√¥ng ƒë·ªß ho·∫∑c user kh√¥ng t·ªìn t·∫°i');
    }

    console.log(`‚úÖ [BALANCE] User ${userId} ƒë·∫∑t l·ªánh ${amount} th√†nh c√¥ng`);
    return true;
  } catch (error) {
    console.error(`‚ùå [BALANCE] L·ªói ƒë·∫∑t l·ªánh user ${userId}:`, error);
    throw error;
  }
}

/**
 * X·ª≠ l√Ω k·∫øt qu·∫£ th·∫Øng - Tr·∫£ l·∫°i ti·ªÅn g·ªëc + c·ªông profit
 */
export async function processWinTrade(db: any, userId: string, tradeAmount: number, profit: number): Promise<boolean> {
  try {
    const updateResult = await db.collection('users').updateOne(
      { _id: new ObjectId(userId) },
      [
        {
          $set: {
            balance: {
              available: {
                $add: [
                  { $ifNull: ['$balance.available', 0] },
                  { $ifNull: ['$balance.frozen', 0] },
                  profit
                ]
              },
              frozen: {
                $subtract: [
                  { $ifNull: ['$balance.frozen', 0] },
                  tradeAmount
                ]
              }
            },
            updatedAt: new Date()
          }
        }
      ]
    );

    if (updateResult.modifiedCount === 0) {
      throw new Error('Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t balance cho user th·∫Øng');
    }

    console.log(`‚úÖ [BALANCE] User ${userId} th·∫Øng: +${tradeAmount + profit}`);
    return true;
  } catch (error) {
    console.error(`‚ùå [BALANCE] L·ªói x·ª≠ l√Ω th·∫Øng user ${userId}:`, error);
    throw error;
  }
}

/**
 * X·ª≠ l√Ω k·∫øt qu·∫£ thua - Ch·ªâ tr·ª´ ti·ªÅn ƒë√≥ng bƒÉng
 */
export async function processLoseTrade(db: any, userId: string, tradeAmount: number): Promise<boolean> {
  try {
    const updateResult = await db.collection('users').updateOne(
      { _id: new ObjectId(userId) },
      [
        {
          $set: {
            balance: {
              available: {
                $add: [
                  { $ifNull: ['$balance.available', 0] },
                  0
                ]
              },
              frozen: {
                $subtract: [
                  { $ifNull: ['$balance.frozen', 0] },
                  tradeAmount
                ]
              }
            },
            updatedAt: new Date()
          }
        }
      ]
    );

    if (updateResult.modifiedCount === 0) {
      throw new Error('Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t balance cho user thua');
    }

    console.log(`‚úÖ [BALANCE] User ${userId} thua: -${tradeAmount}`);
    return true;
  } catch (error) {
    console.error(`‚ùå [BALANCE] L·ªói x·ª≠ l√Ω thua user ${userId}:`, error);
    throw error;
  }
}

/**
 * L·∫•y balance hi·ªán t·∫°i c·ªßa user
 */
export async function getUserBalance(db: any, userId: string): Promise<BalanceUpdate> {
  try {
    const user = await db.collection('users').findOne(
      { _id: new ObjectId(userId) },
      { projection: { balance: 1 } }
    );

    if (!user) {
      throw new Error('User kh√¥ng t·ªìn t·∫°i');
    }

    // Chu·∫©n h√≥a balance format
    let balance = user.balance || { available: 0, frozen: 0 };
    
    // N·∫øu balance l√† number (ki·ªÉu c≈©), chuy·ªÉn ƒë·ªïi th√†nh object
    if (typeof balance === 'number') {
      balance = {
        available: balance,
        frozen: 0
      };
    }

    return {
      available: balance.available || 0,
      frozen: balance.frozen || 0
    };
  } catch (error) {
    console.error(`‚ùå [BALANCE] L·ªói l·∫•y balance user ${userId}:`, error);
    throw error;
  }
}

/**
 * Ki·ªÉm tra balance c√≥ ƒë·ªß ƒë·ªÉ ƒë·∫∑t l·ªánh kh√¥ng
 */
export async function checkBalanceSufficient(db: any, userId: string, amount: number): Promise<boolean> {
  try {
    const balance = await getUserBalance(db, userId);
    return balance.available >= amount;
  } catch (error) {
    console.error(`‚ùå [BALANCE] L·ªói ki·ªÉm tra balance user ${userId}:`, error);
    return false;
  }
}

/**
 * T√≠nh to√°n profit d·ª±a tr√™n amount v√† t·ª∑ l·ªá th·∫Øng
 */
export function calculateProfit(amount: number, winRate: number = 0.9): number {
  return Math.floor(amount * winRate);
}

/**
 * Log balance change ƒë·ªÉ debug
 */
export async function logBalanceChange(db: any, userId: string, operation: string, details: any): Promise<void> {
  try {
    const balance = await getUserBalance(db, userId);
    console.log(`üìä [BALANCE LOG] User ${userId} - ${operation}:`, {
      currentBalance: balance,
      ...details,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error(`‚ùå [BALANCE LOG] L·ªói log balance user ${userId}:`, error);
  }
}
